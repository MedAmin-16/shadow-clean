import type { 
  ScannerFindings, 
  EnhancedScannerFindings, 
  PlanLevel 
} from "@shared/schema";
import { isTargetBlacklisted } from "../utils/targetBlacklist";
import { 
  type EvasionTechnique,
  type StealthLevel,
  type VulnerabilityChain,
  type VulnerabilityChainStep,
  type StealthExploitResult,
  type StealthModeConfig,
  type StealthDecisionLog,
  type StealthDecisionType,
  type ExploiterStealthFindings,
  type ChainTemplate,
  EVASION_TECHNIQUES,
  STEALTH_PROFILES,
  VULNERABILITY_CHAIN_TEMPLATES,
  STEALTH_COSTS,
} from "@shared/stealth";
import { storage } from "../storage";
import { nanoid } from "nanoid";

function randomDelay(min: number, max: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, Math.random() * (max - min) + min));
}

interface ExploiterContext {
  userId: string;
  scanId: string;
  planLevel: PlanLevel;
  stealthConfig: StealthModeConfig;
  decisionLog: StealthDecisionLog[];
  creditsSpent: number;
  detectionEvents: number;
}

function logDecision(
  ctx: ExploiterContext,
  decisionType: StealthDecisionType,
  description: string,
  technique?: EvasionTechnique,
  chainId?: string,
  detectionRisk?: number,
  metadata?: Record<string, unknown>
): void {
  ctx.decisionLog.push({
    timestamp: new Date().toISOString(),
    decisionType,
    description,
    technique,
    chainId,
    detectionRisk,
    metadata,
  });
}

function getEvasionTechniques(stealthLevel: StealthLevel): EvasionTechnique[] {
  return STEALTH_PROFILES[stealthLevel];
}

function applyTimingJitter(ctx: ExploiterContext): Promise<void> {
  const config = EVASION_TECHNIQUES.timing_jitter;
  const minDelay = config.parameters.minDelayMs as number;
  const maxDelay = config.parameters.maxDelayMs as number;
  
  logDecision(ctx, "evasion_technique_applied", 
    `Applied timing jitter: ${minDelay}-${maxDelay}ms delay`, 
    "timing_jitter", undefined, config.detectionRisk);
  
  return randomDelay(minDelay, maxDelay);
}

function applyEncodingObfuscation(payload: string, ctx: ExploiterContext): string {
  const config = EVASION_TECHNIQUES.encoding_obfuscation;
  const encodings = config.parameters.encodings as string[];
  const encoding = encodings[Math.floor(Math.random() * encodings.length)];
  
  let result = payload;
  switch (encoding) {
    case "base64":
      result = Buffer.from(payload).toString("base64");
      break;
    case "url":
      result = encodeURIComponent(payload);
      break;
    case "hex":
      result = Buffer.from(payload).toString("hex");
      break;
    default:
      result = payload;
  }
  
  logDecision(ctx, "evasion_technique_applied",
    `Applied ${encoding} encoding obfuscation`,
    "encoding_obfuscation", undefined, config.detectionRisk);
  
  return result;
}

function generateSpoofedHeaders(ctx: ExploiterContext): Record<string, string> {
  const config = EVASION_TECHNIQUES.header_spoofing;
  
  const userAgents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 Safari/604.1",
  ];
  
  const headers: Record<string, string> = {
    "User-Agent": userAgents[Math.floor(Math.random() * userAgents.length)],
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.5",
  };
  
  if (config.parameters.addXForwardedFor) {
    const randomIP = `${Math.floor(Math.random() * 223) + 1}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
    headers["X-Forwarded-For"] = randomIP;
  }
  
  logDecision(ctx, "evasion_technique_applied",
    "Applied header spoofing with randomized User-Agent and X-Forwarded-For",
    "header_spoofing", undefined, config.detectionRisk);
  
  return headers;
}

function detectWafResponse(ctx: ExploiterContext): boolean {
  const detected = Math.random() < (ctx.stealthConfig.wafDetected ? 0.6 : 0.2);
  
  if (detected) {
    ctx.detectionEvents++;
    logDecision(ctx, "detection_event",
      `WAF detection event #${ctx.detectionEvents} - Response pattern indicates WAF blocking`);
  }
  
  return detected;
}

function detectIdsAlert(ctx: ExploiterContext): boolean {
  const detected = Math.random() < (ctx.stealthConfig.idsDetected ? 0.5 : 0.15);
  
  if (detected) {
    ctx.detectionEvents++;
    logDecision(ctx, "detection_event",
      `IDS detection event #${ctx.detectionEvents} - Potential signature match detected`);
  }
  
  return detected;
}

function adaptStealthLevel(ctx: ExploiterContext): void {
  if (!ctx.stealthConfig.adaptiveMode) return;
  
  const levels: StealthLevel[] = ["passive", "cautious", "aggressive", "maximum"];
  const currentIndex = levels.indexOf(ctx.stealthConfig.stealthLevel);
  
  if (ctx.detectionEvents >= 2 && currentIndex > 0) {
    ctx.stealthConfig.stealthLevel = levels[currentIndex - 1];
    logDecision(ctx, "stealth_level_adjusted",
      `Reduced stealth level to ${ctx.stealthConfig.stealthLevel} due to detection events`);
  }
}

function identifyVulnerabilityChains(
  vulnerabilities: Array<{ title: string; id: string; severity: string }>,
  ctx: ExploiterContext
): VulnerabilityChain[] {
  const chains: VulnerabilityChain[] = [];
  const vulnTitles = vulnerabilities.map(v => v.title);
  
  for (const template of VULNERABILITY_CHAIN_TEMPLATES) {
    const entryVuln = template.entryVulnerabilities.find(entry => 
      vulnTitles.some(t => t.includes(entry) || entry.includes(t.split(" ")[0]))
    );
    
    if (entryVuln) {
      const matchingVuln = vulnerabilities.find(v => 
        v.title.includes(entryVuln) || entryVuln.includes(v.title.split(" ")[0])
      );
      
      if (matchingVuln) {
        const selectedPath = template.escalationPaths[
          Math.floor(Math.random() * template.escalationPaths.length)
        ];
        
        const steps: VulnerabilityChainStep[] = selectedPath.map((step, idx) => ({
          stepNumber: idx + 1,
          vulnerabilityId: idx === 0 ? matchingVuln.id : `derived-${nanoid(6)}`,
          vulnerabilityTitle: step,
          exploitTechnique: `${step} Exploitation`,
          preconditions: idx === 0 ? ["Initial Access"] : [`Step ${idx} completed`],
          expectedOutcome: step,
          accessLevel: idx === selectedPath.length - 1 ? "admin" : 
                       idx > selectedPath.length / 2 ? "execute" : "read",
          persistence: idx === selectedPath.length - 1,
        }));
        
        const chain: VulnerabilityChain = {
          id: `chain-${nanoid(8)}`,
          name: template.name,
          description: template.description,
          steps,
          totalRiskScore: steps.length * 25,
          estimatedTimeMinutes: steps.length * 5,
          requiredCredits: STEALTH_COSTS[ctx.planLevel].perChainCost * steps.length,
          successProbability: Math.max(0.3, 0.9 - (steps.length * 0.1)),
          accessLevelAchieved: steps[steps.length - 1].accessLevel,
          impactCategories: template.impactCategories,
        };
        
        chains.push(chain);
        
        logDecision(ctx, "chain_identified",
          `Identified vulnerability chain: ${template.name} with ${steps.length} steps`,
          undefined, chain.id, undefined, { steps: steps.length });
      }
    }
  }
  
  return chains;
}

async function executeChainStep(
  step: VulnerabilityChainStep,
  chain: VulnerabilityChain,
  ctx: ExploiterContext
): Promise<boolean> {
  const techniques = getEvasionTechniques(ctx.stealthConfig.stealthLevel);
  
  if (techniques.includes("timing_jitter")) {
    await applyTimingJitter(ctx);
  }
  
  if (techniques.includes("header_spoofing")) {
    generateSpoofedHeaders(ctx);
  }
  
  logDecision(ctx, "chain_step_executed",
    `Executing chain step ${step.stepNumber}: ${step.vulnerabilityTitle}`,
    undefined, chain.id);
  
  await randomDelay(200, 500);
  
  const wafBlocked = detectWafResponse(ctx);
  if (wafBlocked && techniques.includes("encoding_obfuscation")) {
    logDecision(ctx, "waf_detected_adapting",
      "WAF blocking detected, applying encoding obfuscation bypass");
    applyEncodingObfuscation("payload", ctx);
    await randomDelay(100, 300);
  }
  
  const idsTriggered = detectIdsAlert(ctx);
  if (idsTriggered && ctx.stealthConfig.adaptiveMode) {
    logDecision(ctx, "ids_detected_adapting",
      "IDS alert detected, adapting attack pattern");
    adaptStealthLevel(ctx);
    await randomDelay(500, 1000);
  }
  
  if (ctx.stealthConfig.abortOnDetection && 
      ctx.detectionEvents >= ctx.stealthConfig.maxDetectionEvents) {
    logDecision(ctx, "abort_triggered",
      `Aborting exploitation - max detection events (${ctx.stealthConfig.maxDetectionEvents}) reached`);
    return false;
  }
  
  const baseSuccessRate = chain.successProbability;
  const stealthBonus = ctx.stealthConfig.stealthLevel === "maximum" ? 0.1 :
                       ctx.stealthConfig.stealthLevel === "aggressive" ? 0.05 : 0;
  const detectionPenalty = ctx.detectionEvents * 0.05;
  
  return Math.random() < (baseSuccessRate + stealthBonus - detectionPenalty);
}

interface ExploitTechnique {
  name: string;
  targetVulns: string[];
  successRate: number;
  evidence: string[];
  stealthCompatible: boolean;
}

const stealthExploitTechniques: ExploitTechnique[] = [
  {
    name: "Stealthy SQL Injection with WAF Bypass",
    targetVulns: ["SQL Injection Vulnerability"],
    successRate: 0.75,
    evidence: [
      "Successfully bypassed WAF using encoding obfuscation",
      "Extracted database schema using time-based blind injection",
      "Retrieved user credentials using out-of-band exfiltration",
    ],
    stealthCompatible: true,
  },
  {
    name: "Encoded XSS Payload Injection",
    targetVulns: ["Cross-Site Scripting (XSS)"],
    successRate: 0.8,
    evidence: [
      "DOM-based XSS executed with polyglot payload",
      "Session token exfiltrated via encoded callback",
    ],
    stealthCompatible: true,
  },
  {
    name: "SSRF with Protocol Smuggling",
    targetVulns: ["Server-Side Request Forgery (SSRF)"],
    successRate: 0.65,
    evidence: [
      "Accessed cloud metadata endpoint via DNS rebinding",
      "Retrieved IAM credentials from metadata service",
    ],
    stealthCompatible: true,
  },
  {
    name: "Privilege Escalation via IDOR Chain",
    targetVulns: ["Insecure Direct Object Reference (IDOR)", "Privilege Escalation Vulnerability"],
    successRate: 0.7,
    evidence: [
      "Enumerated user IDs via timing analysis",
      "Accessed admin resources by manipulating object references",
    ],
    stealthCompatible: true,
  },
  {
    name: "Low-and-Slow Brute Force",
    targetVulns: ["Broken Authentication - Session Fixation"],
    successRate: 0.4,
    evidence: [
      "Valid session obtained using credential stuffing with rate-limit evasion",
    ],
    stealthCompatible: true,
  },
  {
    name: "Polymorphic Log4j Exploitation",
    targetVulns: ["Remote Code Execution (Log4j)"],
    successRate: 0.55,
    evidence: [
      "RCE achieved using obfuscated JNDI lookup",
      "Reverse shell established via encoded payload",
    ],
    stealthCompatible: true,
  },
];

export interface StealthExploiterOptions {
  userId: string;
  scanId: string;
  stealthLevel?: StealthLevel;
  adaptiveMode?: boolean;
  abortOnDetection?: boolean;
  maxDetectionEvents?: number;
  onProgress: (progress: number) => void;
  onDecision?: (decision: StealthDecisionLog) => void;
}

export async function runStealthExploiterAgent(
  target: string,
  scannerData: ScannerFindings | EnhancedScannerFindings,
  options: StealthExploiterOptions
): Promise<ExploiterStealthFindings> {
  const { userId, scanId, onProgress, onDecision } = options;

  const blacklistCheck = isTargetBlacklisted(target);
  if (blacklistCheck.blocked) {
    throw new Error(`SCAN_BLOCKED: ${blacklistCheck.reason}`);
  }
  
  const userCredits = await storage.getUserCredits(userId);
  const planLevel = userCredits.planLevel;
  const costs = STEALTH_COSTS[planLevel];
  
  const wafDetected = "waf_ids_detected" in scannerData && scannerData.waf_ids_detected;
  
  const stealthConfig: StealthModeConfig = {
    enabled: true,
    stealthLevel: options.stealthLevel || (wafDetected ? "aggressive" : "cautious"),
    wafDetected,
    idsDetected: wafDetected,
    adaptiveMode: options.adaptiveMode ?? true,
    maxDetectionEvents: options.maxDetectionEvents ?? 5,
    abortOnDetection: options.abortOnDetection ?? false,
  };
  
  const ctx: ExploiterContext = {
    userId,
    scanId,
    planLevel,
    stealthConfig,
    decisionLog: [],
    creditsSpent: 0,
    detectionEvents: 0,
  };
  
  onProgress(5);
  
  logDecision(ctx, "stealth_mode_activated",
    `Stealth mode activated: Level=${stealthConfig.stealthLevel}, Adaptive=${stealthConfig.adaptiveMode}`);
  
  if (wafDetected) {
    logDecision(ctx, "waf_detected_adapting",
      "WAF/IDS detected from scanner - activating enhanced evasion techniques");
  }
  
  const deductionResult = await storage.deductCredits(userId, costs.baseCost);
  if (!deductionResult.success) {
    throw new Error(deductionResult.error || "Failed to deduct stealth exploiter credits");
  }
  ctx.creditsSpent += costs.baseCost;
  
  const vulnerabilities = scannerData.vulnerabilities;
  const exploitAttempts: StealthExploitResult[] = [];
  
  if (vulnerabilities.length === 0) {
    onProgress(100);
    return {
      exploitAttempts: [],
      accessGained: false,
      riskLevel: "low",
      stealthMode: stealthConfig,
      vulnerabilityChains: [],
      totalDetectionEvents: 0,
      evasionSuccessRate: 1.0,
      creditsDeducted: ctx.creditsSpent,
      stealthDecisionLog: ctx.decisionLog,
    };
  }
  
  await randomDelay(300, 600);
  onProgress(15);
  
  const chains = identifyVulnerabilityChains(
    vulnerabilities.map(v => ({ title: v.title, id: v.id, severity: v.severity })),
    ctx
  );
  
  onProgress(25);
  
  for (const chain of chains) {
    const chainDeduct = await storage.deductCredits(userId, chain.requiredCredits);
    if (chainDeduct.success) {
      ctx.creditsSpent += chain.requiredCredits;
      
      for (const step of chain.steps) {
        const success = await executeChainStep(step, chain, ctx);
        
        exploitAttempts.push({
          vulnerabilityId: step.vulnerabilityId,
          vulnerabilityTitle: step.vulnerabilityTitle,
          success,
          technique: step.exploitTechnique,
          stealthLevel: ctx.stealthConfig.stealthLevel,
          evasionTechniquesUsed: getEvasionTechniques(ctx.stealthConfig.stealthLevel),
          wafEvaded: !ctx.stealthConfig.wafDetected || success,
          idsEvaded: !ctx.stealthConfig.idsDetected || success,
          detectionEvents: ctx.detectionEvents,
          evidence: success ? `Successfully executed ${step.vulnerabilityTitle}` : undefined,
          chainPosition: step.stepNumber,
          chainId: chain.id,
        });
        
        if (!success && ctx.stealthConfig.abortOnDetection) {
          break;
        }
      }
    }
  }
  
  onProgress(60);
  
  const techniques = getEvasionTechniques(ctx.stealthConfig.stealthLevel);
  const progressPerVuln = 30 / Math.max(vulnerabilities.length, 1);
  let currentProgress = 60;
  
  for (const vuln of vulnerabilities) {
    const technique = stealthExploitTechniques.find(t =>
      t.targetVulns.some(tv => vuln.title.includes(tv) || tv.includes(vuln.title.split(" ")[0]))
    );
    
    if (technique && technique.stealthCompatible) {
      if (techniques.includes("timing_jitter")) {
        await applyTimingJitter(ctx);
      }
      
      detectWafResponse(ctx);
      detectIdsAlert(ctx);
      adaptStealthLevel(ctx);
      
      const stealthBonus = techniques.length * 0.02;
      const success = Math.random() < (technique.successRate + stealthBonus);
      
      exploitAttempts.push({
        vulnerabilityId: vuln.id,
        vulnerabilityTitle: vuln.title,
        success,
        technique: technique.name,
        stealthLevel: ctx.stealthConfig.stealthLevel,
        evasionTechniquesUsed: techniques,
        wafEvaded: !wafDetected || success,
        idsEvaded: !wafDetected || success,
        detectionEvents: ctx.detectionEvents,
        evidence: success
          ? technique.evidence[Math.floor(Math.random() * technique.evidence.length)]
          : undefined,
      });
    } else {
      exploitAttempts.push({
        vulnerabilityId: vuln.id,
        vulnerabilityTitle: vuln.title,
        success: false,
        technique: "Generic Stealth Exploit Attempt",
        stealthLevel: ctx.stealthConfig.stealthLevel,
        evasionTechniquesUsed: techniques,
        wafEvaded: false,
        idsEvaded: false,
        detectionEvents: ctx.detectionEvents,
      });
    }
    
    currentProgress += progressPerVuln;
    onProgress(Math.min(95, Math.round(currentProgress)));
  }
  
  onProgress(100);
  
  const successfulExploits = exploitAttempts.filter(e => e.success).length;
  const criticalVulns = vulnerabilities.filter(v => v.severity === "critical").length;
  const highVulns = vulnerabilities.filter(v => v.severity === "high").length;
  
  let riskLevel: "critical" | "high" | "medium" | "low";
  if (successfulExploits > 0 && criticalVulns > 0) riskLevel = "critical";
  else if (successfulExploits > 0 || criticalVulns > 0) riskLevel = "high";
  else if (highVulns > 0) riskLevel = "medium";
  else riskLevel = "low";
  
  const totalAttempts = exploitAttempts.length;
  const evasionSuccessRate = totalAttempts > 0 
    ? exploitAttempts.filter(e => e.wafEvaded && e.idsEvaded).length / totalAttempts
    : 1.0;
  
  if (onDecision) {
    ctx.decisionLog.forEach(d => onDecision(d));
  }
  
  return {
    exploitAttempts,
    accessGained: exploitAttempts.some(e => e.success),
    riskLevel,
    stealthMode: ctx.stealthConfig,
    vulnerabilityChains: chains,
    totalDetectionEvents: ctx.detectionEvents,
    evasionSuccessRate,
    creditsDeducted: ctx.creditsSpent,
    stealthDecisionLog: ctx.decisionLog,
  };
}
