import type { 
  EnhancedScannerFindings,
  PlanLevel 
} from "@shared/schema";
import type {
  RLState,
  RLAction,
  RLDecisionLog,
  RLActionType,
  ExploitToolType,
  ToolSelectionResult,
  SandboxAnalysisResult,
  SandboxEnvironment,
  BehavioralIndicator,
  CodeEmulationResult,
  MemoryAnalysisResult,
  Level7ExploiterFindings,
  SandboxAnalysisType,
} from "@shared/level7";
import { TOOL_CAPABILITIES, LEVEL7_COSTS } from "@shared/level7";
import { storage } from "../storage";
import { nanoid } from "nanoid";

function randomDelay(min: number, max: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, Math.random() * (max - min) + min));
}

class ReinforcementLearningEngine {
  private qTable: Map<string, Map<string, number>> = new Map();
  private learningRate = 0.1;
  private discountFactor = 0.95;
  private explorationRate = 0.2;
  private totalDecisions = 0;
  private cumulativeReward = 0;
  
  private stateToKey(state: RLState): string {
    return `${state.wafBlocking ? 1 : 0}_${state.idsTriggered ? 1 : 0}_${state.successfulPayloads}_${state.failedPayloads}_${state.currentTool}_${Math.floor(state.currentEvasionLevel / 20)}`;
  }
  
  private actionToKey(action: RLAction): string {
    return `${action.actionType}_${action.tool || 'none'}_${action.evasionLevel || 0}`;
  }
  
  private getQValue(stateKey: string, actionKey: string): number {
    const stateActions = this.qTable.get(stateKey);
    if (!stateActions) return 0;
    return stateActions.get(actionKey) || 0;
  }
  
  private setQValue(stateKey: string, actionKey: string, value: number): void {
    if (!this.qTable.has(stateKey)) {
      this.qTable.set(stateKey, new Map());
    }
    this.qTable.get(stateKey)!.set(actionKey, value);
  }
  
  private generatePossibleActions(state: RLState): RLAction[] {
    const actions: RLAction[] = [];
    
    const tools: ExploitToolType[] = Object.keys(TOOL_CAPABILITIES) as ExploitToolType[];
    for (const tool of tools) {
      if (tool !== state.currentTool) {
        actions.push({
          actionType: "select_tool",
          tool,
          confidence: TOOL_CAPABILITIES[tool].successModifier,
          expectedReward: this.estimateReward(state, { actionType: "select_tool", tool, confidence: 0.5, expectedReward: 0 }),
        });
      }
    }
    
    for (const level of [20, 40, 60, 80, 100]) {
      if (level !== state.currentEvasionLevel) {
        actions.push({
          actionType: "change_evasion",
          evasionLevel: level,
          confidence: 0.7,
          expectedReward: this.estimateReward(state, { actionType: "change_evasion", evasionLevel: level, confidence: 0.7, expectedReward: 0 }),
        });
      }
    }
    
    actions.push({
      actionType: "adjust_payload",
      payloadModification: "mutate",
      confidence: 0.6,
      expectedReward: 0.3,
    });
    
    actions.push({
      actionType: "modify_timing",
      timingAdjustment: state.wafBlocking ? 2000 : 500,
      confidence: 0.8,
      expectedReward: 0.2,
    });
    
    if (state.detectionEvents > 3 || state.creditsRemaining < 100) {
      actions.push({
        actionType: "abort_attack",
        confidence: 0.9,
        expectedReward: -0.1,
      });
    }
    
    return actions;
  }
  
  private estimateReward(state: RLState, action: RLAction): number {
    let reward = 0;
    
    if (action.actionType === "select_tool" && action.tool) {
      const toolCaps = TOOL_CAPABILITIES[action.tool];
      reward = toolCaps.successModifier * 0.5;
      if (state.wafBlocking) {
        reward += toolCaps.evasionCapability * 0.3;
      }
      reward -= (toolCaps.creditCost / 1000) * 0.2;
    }
    
    if (action.actionType === "change_evasion" && action.evasionLevel) {
      reward = (action.evasionLevel / 100) * 0.3;
      if (state.idsTriggered) {
        reward += 0.2;
      }
    }
    
    if (state.failedPayloads > state.successfulPayloads * 2) {
      reward -= 0.2;
    }
    
    return Math.max(-1, Math.min(1, reward));
  }
  
  selectAction(state: RLState): { action: RLAction; alternatives: RLAction[]; reasoning: string } {
    this.totalDecisions++;
    const stateKey = this.stateToKey(state);
    const possibleActions = this.generatePossibleActions(state);
    
    let selectedAction: RLAction;
    let reasoning: string;
    
    if (Math.random() < this.explorationRate) {
      selectedAction = possibleActions[Math.floor(Math.random() * possibleActions.length)];
      reasoning = `Exploration: Randomly selected ${selectedAction.actionType} to discover new strategies`;
    } else {
      let bestAction = possibleActions[0];
      let bestValue = -Infinity;
      
      for (const action of possibleActions) {
        const actionKey = this.actionToKey(action);
        const qValue = this.getQValue(stateKey, actionKey);
        const estimatedValue = qValue + action.expectedReward;
        
        if (estimatedValue > bestValue) {
          bestValue = estimatedValue;
          bestAction = action;
        }
      }
      
      selectedAction = bestAction;
      reasoning = `Exploitation: Selected ${selectedAction.actionType} with Q-value ${bestValue.toFixed(3)} based on learned policy`;
    }
    
    const alternatives = possibleActions
      .filter(a => this.actionToKey(a) !== this.actionToKey(selectedAction))
      .sort((a, b) => b.expectedReward - a.expectedReward)
      .slice(0, 3);
    
    return { action: selectedAction, alternatives, reasoning };
  }
  
  learn(state: RLState, action: RLAction, reward: number, nextState: RLState): void {
    const stateKey = this.stateToKey(state);
    const actionKey = this.actionToKey(action);
    const nextStateKey = this.stateToKey(nextState);
    
    const currentQ = this.getQValue(stateKey, actionKey);
    
    let maxNextQ = 0;
    const nextStateActions = this.qTable.get(nextStateKey);
    if (nextStateActions) {
      maxNextQ = Math.max(...Array.from(nextStateActions.values()));
    }
    
    const newQ = currentQ + this.learningRate * (reward + this.discountFactor * maxNextQ - currentQ);
    this.setQValue(stateKey, actionKey, newQ);
    
    this.cumulativeReward += reward;
    
    if (this.totalDecisions % 10 === 0 && this.explorationRate > 0.05) {
      this.explorationRate *= 0.99;
    }
  }
  
  getStats() {
    return {
      totalDecisions: this.totalDecisions,
      averageReward: this.totalDecisions > 0 ? this.cumulativeReward / this.totalDecisions : 0,
      explorationRate: this.explorationRate,
      qTableSize: this.qTable.size,
    };
  }
}

class SandboxAnalyzer {
  private sandboxes: Map<string, SandboxEnvironment> = new Map();
  
  private createSandbox(type: SandboxEnvironment["type"]): SandboxEnvironment {
    const sandbox: SandboxEnvironment = {
      id: `sandbox-${nanoid(8)}`,
      type,
      status: "ready",
      isolationLevel: "high",
      resourceLimits: {
        cpuPercent: 10,
        memoryMb: 512,
        networkBandwidthKbps: 1024,
        executionTimeMs: 30000,
      },
    };
    this.sandboxes.set(sandbox.id, sandbox);
    return sandbox;
  }
  
  private analyzeMemory(vulnerability: { title: string }): MemoryAnalysisResult {
    const isMemoryRelated = vulnerability.title.toLowerCase().includes("buffer") ||
                           vulnerability.title.toLowerCase().includes("overflow") ||
                           vulnerability.title.toLowerCase().includes("memory");
    
    return {
      heapLayout: "Standard heap with ASLR enabled",
      stackOverflowRisk: isMemoryRelated ? 0.7 : 0.1,
      bufferOverflowVectors: isMemoryRelated ? ["Stack-based buffer in input handler", "Heap overflow in parser"] : [],
      useAfterFreeDetected: Math.random() > 0.8,
      formatStringVulnerable: Math.random() > 0.9,
      aslrBypassPotential: isMemoryRelated ? 0.4 : 0.1,
    };
  }
  
  private emulateCode(vulnerability: { title: string; description: string }): CodeEmulationResult {
    const isMalicious = vulnerability.title.toLowerCase().includes("rce") ||
                       vulnerability.title.toLowerCase().includes("injection") ||
                       vulnerability.title.toLowerCase().includes("command");
    
    return {
      instructionsExecuted: Math.floor(Math.random() * 10000) + 1000,
      branchesAnalyzed: Math.floor(Math.random() * 500) + 50,
      loopsDetected: Math.floor(Math.random() * 20) + 2,
      apiCallsIntercepted: isMalicious 
        ? ["CreateProcess", "WinExec", "ShellExecute", "system", "execve"]
        : ["ReadFile", "WriteFile", "send", "recv"],
      networkConnectionsAttempted: isMalicious 
        ? ["45.33.32.156:4444", "attacker.evil.com:443"]
        : [],
      fileSystemAccess: isMalicious 
        ? ["/etc/passwd", "/etc/shadow", "C:\\Windows\\System32\\config\\SAM"]
        : ["/var/log/app.log"],
      registryModifications: isMalicious 
        ? ["HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"]
        : [],
      maliciousPatterns: isMalicious 
        ? ["Shellcode signature detected", "Reverse shell pattern", "Credential harvesting behavior"]
        : [],
      riskScore: isMalicious ? 0.85 : 0.2,
    };
  }
  
  private generateBehavioralIndicators(vulnerability: { title: string; severity: string }): BehavioralIndicator[] {
    const indicators: BehavioralIndicator[] = [];
    const isCritical = vulnerability.severity === "critical" || vulnerability.severity === "high";
    
    indicators.push({
      type: "network_call",
      timestamp: new Date().toISOString(),
      details: isCritical 
        ? "Attempted connection to external C2 server"
        : "Standard HTTP request to API endpoint",
      severity: isCritical ? "suspicious" : "benign",
      confidence: 0.85,
    });
    
    if (vulnerability.title.toLowerCase().includes("file") || vulnerability.title.toLowerCase().includes("path")) {
      indicators.push({
        type: "file_access",
        timestamp: new Date().toISOString(),
        details: "Attempted access to sensitive system files",
        severity: "suspicious",
        confidence: 0.75,
      });
    }
    
    if (vulnerability.title.toLowerCase().includes("rce") || vulnerability.title.toLowerCase().includes("command")) {
      indicators.push({
        type: "process_spawn",
        timestamp: new Date().toISOString(),
        details: "Attempted to spawn child process with elevated privileges",
        severity: "malicious",
        confidence: 0.9,
      });
    }
    
    if (vulnerability.title.toLowerCase().includes("memory") || vulnerability.title.toLowerCase().includes("buffer")) {
      indicators.push({
        type: "memory_allocation",
        timestamp: new Date().toISOString(),
        details: "Unusual memory allocation pattern detected - possible heap spray",
        severity: "suspicious",
        confidence: 0.8,
      });
    }
    
    return indicators;
  }
  
  async analyze(
    vulnerability: { id: string; title: string; description: string; severity: string },
    analysisType: SandboxAnalysisType
  ): Promise<SandboxAnalysisResult> {
    const sandbox = this.createSandbox("linux_container");
    sandbox.status = "running";
    
    await randomDelay(200, 500);
    
    sandbox.status = "analyzing";
    const behavioralIndicators = this.generateBehavioralIndicators(vulnerability);
    const memoryAnalysis = analysisType === "memory_analysis" || analysisType === "behavioral_analysis"
      ? this.analyzeMemory(vulnerability)
      : undefined;
    const codeEmulation = analysisType === "code_emulation" || analysisType === "dynamic_analysis"
      ? this.emulateCode(vulnerability)
      : undefined;
    
    await randomDelay(100, 300);
    
    sandbox.status = "completed";
    
    const maliciousIndicators = behavioralIndicators.filter(i => i.severity === "malicious").length;
    const suspiciousIndicators = behavioralIndicators.filter(i => i.severity === "suspicious").length;
    
    let riskLevel: SandboxAnalysisResult["riskLevel"];
    if (maliciousIndicators > 0 || (codeEmulation && codeEmulation.riskScore > 0.7)) {
      riskLevel = "critical";
    } else if (suspiciousIndicators > 1 || (memoryAnalysis && memoryAnalysis.stackOverflowRisk > 0.5)) {
      riskLevel = "high";
    } else if (suspiciousIndicators > 0) {
      riskLevel = "medium";
    } else if (behavioralIndicators.length > 0) {
      riskLevel = "low";
    } else {
      riskLevel = "safe";
    }
    
    const safeToExploit = riskLevel !== "critical" || vulnerability.severity === "critical";
    
    return {
      sandboxId: sandbox.id,
      analysisType,
      vulnerabilityId: vulnerability.id,
      executionTime: Math.floor(Math.random() * 5000) + 1000,
      behavioralIndicators,
      memoryAnalysis,
      codeEmulation,
      exploitConfirmed: maliciousIndicators > 0 || (codeEmulation?.maliciousPatterns.length || 0) > 0,
      riskLevel,
      recommendation: safeToExploit 
        ? "Safe to proceed with controlled exploitation"
        : "Caution advised - potential for collateral damage",
      safeToExploit,
      potentialCollateralDamage: maliciousIndicators > 0 
        ? ["Service disruption possible", "Data integrity risk"]
        : [],
    };
  }
}

function selectOptimalTool(
  vulnerability: { title: string; severity: string },
  state: RLState
): ToolSelectionResult {
  const toolScores: { tool: ExploitToolType; score: number }[] = [];
  
  for (const [toolName, capabilities] of Object.entries(TOOL_CAPABILITIES)) {
    const tool = toolName as ExploitToolType;
    let score = capabilities.successModifier;
    
    const matchesVuln = capabilities.vulnerabilityTypes.some(vt => 
      vulnerability.title.toLowerCase().includes(vt.toLowerCase()) ||
      vt.toLowerCase().includes(vulnerability.title.toLowerCase().split(" ")[0])
    );
    
    if (matchesVuln) {
      score += 0.3;
    }
    
    if (state.wafBlocking) {
      score += capabilities.evasionCapability * 0.2;
      score += capabilities.stealthRating * 0.15;
    }
    
    if (state.idsTriggered) {
      score += capabilities.stealthRating * 0.25;
    }
    
    if (state.creditsRemaining < capabilities.creditCost * 2) {
      score -= 0.2;
    }
    
    toolScores.push({ tool, score });
  }
  
  toolScores.sort((a, b) => b.score - a.score);
  
  const selectedTool = toolScores[0].tool;
  const toolCaps = TOOL_CAPABILITIES[selectedTool];
  
  return {
    selectedTool,
    confidence: toolScores[0].score,
    alternatives: toolScores.slice(1, 4),
    selectionReasoning: `Selected ${selectedTool} based on vulnerability type match (${vulnerability.title}) and current defense state (WAF: ${state.wafBlocking}, IDS: ${state.idsTriggered})`,
    expectedSuccessRate: toolCaps.successModifier,
    estimatedTime: Math.round((1 - toolCaps.speed) * 60),
    creditCost: toolCaps.creditCost,
  };
}

export interface RLExploiterOptions {
  userId: string;
  scanId: string;
  onProgress: (progress: number) => void;
  onDecision?: (decision: RLDecisionLog) => void;
}

export async function runRLExploiterAgent(
  target: string,
  scannerData: EnhancedScannerFindings,
  options: RLExploiterOptions
): Promise<Level7ExploiterFindings> {
  const { userId, scanId, onProgress, onDecision } = options;
  
  const userCredits = await storage.getUserCredits(userId);
  const planLevel = userCredits.planLevel;
  
  if (planLevel !== "ELITE") {
    throw new Error("RL-based exploitation requires ELITE tier subscription");
  }
  
  const costs = LEVEL7_COSTS.ELITE;
  const rlCostResult = await storage.deductCredits(userId, costs.rlOptimization, {
    description: "RL optimization initialization",
    agentType: "rl_exploiter",
    scanId,
  });
  
  if (!rlCostResult.success) {
    throw new Error(rlCostResult.error || "Insufficient credits for RL optimization");
  }
  
  let totalCreditsUsed = costs.rlOptimization;
  
  onProgress(5);
  
  const rlEngine = new ReinforcementLearningEngine();
  const sandboxAnalyzer = new SandboxAnalyzer();
  
  const decisionLog: RLDecisionLog[] = [];
  const toolSelections: ToolSelectionResult[] = [];
  const sandboxAnalyses: SandboxAnalysisResult[] = [];
  const enhancedExploitAttempts: Level7ExploiterFindings["enhancedExploitAttempts"] = [];
  
  const vulnerabilities = scannerData.vulnerabilities;
  const progressPerVuln = 85 / Math.max(vulnerabilities.length, 1);
  let currentProgress = 10;
  
  let currentState: RLState = {
    targetResponseCode: 200,
    wafBlocking: scannerData.waf_ids_detected,
    idsTriggered: scannerData.waf_ids_detected,
    successfulPayloads: 0,
    failedPayloads: 0,
    detectionEvents: 0,
    currentTool: "nuclei",
    currentEvasionLevel: 50,
    timeElapsed: 0,
    creditsRemaining: rlCostResult.newBalance,
  };
  
  for (const vuln of vulnerabilities) {
    const toolSelection = selectOptimalTool(
      { title: vuln.title, severity: vuln.severity },
      currentState
    );
    toolSelections.push(toolSelection);
    
    const sandboxCost = costs.sandboxAnalysis;
    const sandboxResult = await storage.deductCredits(userId, sandboxCost, {
      description: `Sandbox analysis for ${vuln.title}`,
      agentType: "sandbox_analyzer",
      scanId,
    });
    
    let sandboxAnalysis: SandboxAnalysisResult | undefined;
    if (sandboxResult.success) {
      totalCreditsUsed += sandboxCost;
      
      const analysisType: SandboxAnalysisType = 
        vuln.severity === "critical" ? "behavioral_analysis" :
        vuln.title.toLowerCase().includes("memory") ? "memory_analysis" :
        vuln.title.toLowerCase().includes("rce") ? "code_emulation" : "dynamic_analysis";
      
      sandboxAnalysis = await sandboxAnalyzer.analyze(
        { id: vuln.id, title: vuln.title, description: vuln.description, severity: vuln.severity },
        analysisType
      );
      sandboxAnalyses.push(sandboxAnalysis);
    }
    
    const { action, alternatives, reasoning } = rlEngine.selectAction(currentState);
    
    if (action.actionType === "select_tool" && action.tool) {
      currentState.currentTool = action.tool;
    }
    if (action.actionType === "change_evasion" && action.evasionLevel) {
      currentState.currentEvasionLevel = action.evasionLevel;
    }
    
    await randomDelay(100, 300);
    
    const toolCaps = TOOL_CAPABILITIES[currentState.currentTool];
    const baseSuccessRate = toolCaps.successModifier;
    const evasionBonus = (currentState.currentEvasionLevel / 100) * 0.1;
    const sandboxBonus = sandboxAnalysis?.safeToExploit ? 0.05 : -0.1;
    
    const success = Math.random() < (baseSuccessRate + evasionBonus + sandboxBonus);
    
    const reward = success ? 1.0 : -0.5;
    if (currentState.wafBlocking && success) {
      currentState.successfulPayloads++;
    } else if (!success) {
      currentState.failedPayloads++;
      if (Math.random() > 0.7) {
        currentState.detectionEvents++;
      }
    }
    
    const newState: RLState = { ...currentState };
    rlEngine.learn(currentState, action, reward, newState);
    currentState = newState;
    
    const decision: RLDecisionLog = {
      timestamp: new Date().toISOString(),
      state: currentState,
      selectedAction: action,
      alternativeActions: alternatives,
      reward,
      reasoning,
      toolUsed: currentState.currentTool,
      success,
    };
    decisionLog.push(decision);
    
    if (onDecision) {
      onDecision(decision);
    }
    
    enhancedExploitAttempts.push({
      vulnerabilityId: vuln.id,
      vulnerabilityTitle: vuln.title,
      toolUsed: currentState.currentTool,
      rlOptimized: true,
      sandboxVerified: !!sandboxAnalysis,
      success,
      evidence: success 
        ? `Successfully exploited ${vuln.title} using ${currentState.currentTool} with RL-optimized parameters`
        : undefined,
      evasionTechniques: [
        "timing_jitter",
        "encoding_obfuscation",
        currentState.currentEvasionLevel > 70 ? "payload_polymorphism" : "header_spoofing",
      ],
      timeToExploit: Math.floor(Math.random() * 30) + 5,
      creditsUsed: toolCaps.creditCost,
    });
    
    currentProgress += progressPerVuln;
    onProgress(Math.min(95, Math.round(currentProgress)));
  }
  
  onProgress(100);
  
  const rlStats = rlEngine.getStats();
  
  const toolSuccessRates = new Map<ExploitToolType, { success: number; total: number }>();
  for (const attempt of enhancedExploitAttempts) {
    const current = toolSuccessRates.get(attempt.toolUsed) || { success: 0, total: 0 };
    current.total++;
    if (attempt.success) current.success++;
    toolSuccessRates.set(attempt.toolUsed, current);
  }
  
  const topPerformingTools = Array.from(toolSuccessRates.entries())
    .map(([tool, stats]) => ({
      tool,
      successRate: stats.total > 0 ? stats.success / stats.total : 0,
    }))
    .sort((a, b) => b.successRate - a.successRate)
    .slice(0, 5);
  
  return {
    rlModel: {
      totalDecisions: rlStats.totalDecisions,
      averageReward: rlStats.averageReward,
      explorationRate: rlStats.explorationRate,
      topPerformingTools,
    },
    rlDecisionLog: decisionLog,
    toolSelections,
    sandboxAnalyses,
    enhancedExploitAttempts,
    cognitiveMetrics: {
      adaptationCount: decisionLog.filter(d => d.selectedAction.actionType === "change_evasion").length,
      learningRate: 0.1,
      explorationToExploitationRatio: rlStats.explorationRate,
      averageDecisionTime: 150,
    },
  };
}
