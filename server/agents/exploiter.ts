import type { ExploiterFindings, ScannerFindings, EnhancedScannerFindings } from "@shared/schema";
import { isTargetBlacklisted } from "../utils/targetBlacklist";

function randomDelay(min: number, max: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, Math.random() * (max - min) + min));
}

interface ExploitTechnique {
  name: string;
  targetVulns: string[];
  successRate: number;
  evidence: string[];
}

const exploitTechniques: ExploitTechnique[] = [
  {
    name: "SQL Injection Payload Injection",
    targetVulns: ["SQL Injection Vulnerability"],
    successRate: 0.7,
    evidence: [
      "Successfully extracted database schema",
      "Retrieved user credentials from database",
      "Bypassed authentication via SQL injection",
    ],
  },
  {
    name: "XSS Payload Delivery",
    targetVulns: ["Cross-Site Scripting (XSS)"],
    successRate: 0.8,
    evidence: [
      "Cookie theft payload executed successfully",
      "Session token captured via reflected XSS",
    ],
  },
  {
    name: "SSH Brute Force",
    targetVulns: ["Outdated OpenSSH Version"],
    successRate: 0.3,
    evidence: [
      "Valid SSH credentials discovered: admin:admin123",
      "SSH session established with limited privileges",
    ],
  },
  {
    name: "SSL/TLS Downgrade Attack",
    targetVulns: ["SSL/TLS Configuration Weakness"],
    successRate: 0.5,
    evidence: [
      "Successfully downgraded connection to TLS 1.0",
      "Captured encrypted traffic for offline analysis",
    ],
  },
  {
    name: "Directory Traversal",
    targetVulns: ["Directory Listing Enabled"],
    successRate: 0.6,
    evidence: [
      "Accessed /etc/passwd via path traversal",
      "Retrieved configuration files from parent directories",
    ],
  },
  {
    name: "FTP Anonymous Access Exploitation",
    targetVulns: ["FTP Anonymous Login Enabled"],
    successRate: 0.9,
    evidence: [
      "Downloaded sensitive files from FTP server",
      "Uploaded test file to verify write access",
    ],
  },
  {
    name: "SMB Relay Attack",
    targetVulns: ["SMB Signing Not Required"],
    successRate: 0.4,
    evidence: [
      "Successfully relayed authentication to target",
      "Obtained NTLM hash for offline cracking",
    ],
  },
  {
    name: "MySQL Credential Attack",
    targetVulns: ["Default MySQL Credentials"],
    successRate: 0.85,
    evidence: [
      "Connected to MySQL with default credentials",
      "Extracted sensitive data from production database",
    ],
  },
  {
    name: "Log4j JNDI Injection",
    targetVulns: ["Remote Code Execution (Log4j)"],
    successRate: 0.6,
    evidence: [
      "LDAP callback received - RCE confirmed",
      "Established reverse shell connection",
    ],
  },
  {
    name: "CSRF Token Bypass",
    targetVulns: ["Cross-Site Request Forgery (CSRF)"],
    successRate: 0.7,
    evidence: [
      "Successfully performed unauthorized state-changing action",
      "Modified user account settings via CSRF",
    ],
  },
];

function calculateRiskLevel(
  exploitAttempts: ExploiterFindings["exploitAttempts"],
  vulnerabilities: ScannerFindings["vulnerabilities"]
): ExploiterFindings["riskLevel"] {
  const successfulExploits = exploitAttempts.filter(e => e.success).length;
  const criticalVulns = vulnerabilities.filter(v => v.severity === "critical").length;
  const highVulns = vulnerabilities.filter(v => v.severity === "high").length;

  if (successfulExploits > 0 && criticalVulns > 0) return "critical";
  if (successfulExploits > 0 || criticalVulns > 0) return "high";
  if (highVulns > 0) return "medium";
  return "low";
}

export async function runExploiterAgent(
  target: string,
  scannerData: ScannerFindings | EnhancedScannerFindings,
  onProgress: (progress: number) => void
): Promise<ExploiterFindings> {
  const blacklistCheck = isTargetBlacklisted(target);
  if (blacklistCheck.blocked) {
    throw new Error(`SCAN_BLOCKED: ${blacklistCheck.reason}`);
  }

  onProgress(5);
  await randomDelay(300, 600);

  const vulnerabilities = scannerData.vulnerabilities;
  const exploitAttempts: ExploiterFindings["exploitAttempts"] = [];

  if (vulnerabilities.length === 0) {
    onProgress(100);
    return {
      exploitAttempts: [],
      accessGained: false,
      riskLevel: "low",
    };
  }

  const progressPerVuln = 85 / vulnerabilities.length;
  let currentProgress = 10;

  for (const vuln of vulnerabilities) {
    const technique = exploitTechniques.find(t => 
      t.targetVulns.includes(vuln.title)
    );

    if (technique) {
      await randomDelay(400, 900);
      
      const success = Math.random() < technique.successRate;
      
      exploitAttempts.push({
        vulnerability: vuln.title,
        success,
        technique: technique.name,
        evidence: success 
          ? technique.evidence[Math.floor(Math.random() * technique.evidence.length)]
          : undefined,
      });
    } else {
      exploitAttempts.push({
        vulnerability: vuln.title,
        success: false,
        technique: "Generic Exploit Attempt",
      });
    }

    currentProgress += progressPerVuln;
    onProgress(Math.min(95, Math.round(currentProgress)));
    await randomDelay(200, 500);
  }

  onProgress(100);

  const accessGained = exploitAttempts.some(e => e.success);
  const riskLevel = calculateRiskLevel(exploitAttempts, vulnerabilities);

  return {
    exploitAttempts,
    accessGained,
    riskLevel,
  };
}
